# 后台 cms 登录处理
- 1.封装axios
- 2.登录接口请求
- 3.totken缓存
- 4.登录鉴权




### vite-env配置 import.meta.env 读取编辑器报错 
vscode编辑器错误信息: `类型“ImportMeta”上不存在属性“env”。ts(2339)`

简版解决办法: `env.d.ts`
```typescript
...
// 加入ImportMeta接口定义
interface ImportMeta {
	env: Record<string, unknown>
}
```

详细解决办法二: `env.d.ts`
```typescript
...
// 加入ImportMeta,ImportMetaEnv接口定义
interface ImportMeta {
  env: ImportMetaEnv
}
interface ImportMetaEnv {
  [key: string]: string | boolean | undefined
  BASE_URL: string
  MODE: string
  DEV: boolean
  PROD: boolean
  SSR: boolean
}
```




### 封装axios
+ 根据不同环境变量加载不同的`baseUrl`
```typescript
// axios封装
import axios, { AxiosRequestConfig, AxiosError, AxiosResponse } from 'axios'

const service = axios.create({
  baseURL: String(import.meta.env.VITE_APP_BASE_URL) || '',
  timeout: Number(import.meta.env.VITE_APP_TIME_OUT) || 5000
})

// 请求拦截器
service.interceptors.request.use(
  (config: AxiosRequestConfig) => {
    // 请求配置的处理
    // exp: 请求头携带token的操作
    return config
  },
  (error: AxiosError) => {
    return Promise.reject(error)
  }
)

// 响应拦截器
service.interceptors.response.use(
  (response: AxiosResponse) => {
    // 请求有相应
    // 2xx
    const status = response.status
    if (String(status).charAt(0) === '2') {
      return response.data
    }
    // 3xx 4xx 5xx
    // 状态码+错误码-统一处理: 弹窗...
    console.error(response)
    return Promise.reject(response)
  },
  (error: AxiosError) => {
    // 请求超时，网络异常
    if (error?.response) {
      // 弹窗处理
      const status = error?.response.status
      console.error('请求异常，status:', status)
    }
    if (error.code === 'ECONNABORTED' && error.message.includes('timeout')) {
      // 弹窗处理或重新发生请求
      console.error('请求超时')
    }

    // 可以交给页面单独处理
    return Promise.reject(error)
  }
)

/**
 * get
 * @param url 请求地址
 * @param params query参数对象: key-value
 * @param config 其他配置
 * @returns Promise
 */
function get<T>(
  url: string,
  params?: Record<string, any>,
  config?: AxiosRequestConfig
): Promise<T> {
  return service.get(url, { params, ...config })
}

/**
 * post
 * @param url 请求地址
 * @param data body参数, key-value
 * @param config 其他配置
 * @returns Promise
 */
function post<T>(
  url: string,
  data?: Record<string, any>,
  config?: AxiosRequestConfig
): Promise<T> {
  return service.post(url, data, config)
}

/**
 * put
 * @param url 请求地址
 * @param data body参数对象, key-value
 * @param config 其他配置
 * @returns Promise
 */
function put<T>(
  url: string,
  data?: Record<string, any>,
  config?: AxiosRequestConfig
): Promise<T> {
  return service.put(url, data, config)
}

/**
 * _delete 删除资源,无响应结果
 * 可使用post来设计资源删除,令请求有返回结果
 * @param url 请求地址
 * @param config 其他配置
 * @returns Promise
 */
function _delete(url: string, config?: AxiosRequestConfig): Promise<void> {
  return service.delete(url, config)
}

export { get, post, put, _delete }
export default service
```





### 本地开发-服务代理配置
- vite.config.ts
```typescript
{
  ...
  server: {
  	proxy: {
  	  '/api': {
  	  	target: '目标服务器地址',
  	  	changeOrigin: true,
  	  	rewrite: path=>path.replace(/^\/api/, '') // 以 /api 的变成 ''
  	  }
  	}
  }
}
```




### 前端登录密码加密传输
- 1.无论啥情况,都做加密处理
- 2.前端页面用CryptoJS加密前端登录密码，采用AES算法的CBC模式加密。
- 3.后端用CryptoJS-AES解密。规定好: 公钥+偏移钥
- 4.我们这里采用加密策略: 账号用 aes, 密码用 aes(base64)

简单封装`crypto.ts`:
```ts
import { AES, enc, mode, pad } from 'crypto-js'

// AES-key公钥
const AESKey = String(import.meta.env.VITE_APP_AESKEY32)
// AES-key-iv偏移钥
const AESIV = String(import.meta.env.VITE_APP_AESIV16)

/**
 * AES明文加密
 * @param msg 明文
 * @returns
 */
const useAESEncrypt = (msg: string) => {
  const skey = enc.Utf8.parse(AESKey)
  const srcs = enc.Utf8.parse(msg)
  const optiops = {
    iv: enc.Utf8.parse(AESIV),
    mode: mode.CBC,
    padding: pad.Pkcs7
  }

  const encrypted = AES.encrypt(srcs, skey, optiops)

  return encrypted.ciphertext.toString().toUpperCase()
}

/**
 * AES密文解密
 * @param msg 密文
 * @returns
 */
const useAESDecrypt = (msg: string) => {
  const skey = enc.Utf8.parse(AESKey)
  const hexStr = enc.Hex.parse(msg)
  const srcs = enc.Base64.stringify(hexStr)
  const optiops = {
    iv: enc.Utf8.parse(AESIV),
    mode: mode.CBC,
    padding: pad.Pkcs7
  }

  const decrypted = AES.decrypt(srcs, skey, optiops)
  const decryptedStr = decrypted.toString(enc.Utf8)
  return decryptedStr.toString()
}

/**
 * base64加密
 * @param msg 明文
 * @returns
 */
const useBase64Encrypt = (msg: string) => {
  return enc.Base64.stringify(enc.Utf8.parse(msg))
}

/**
 * base64解密
 * @param msg 密文
 * @returns
 */
const useBase64Decrypt = (msg: string) => {
  return enc.Base64.parse(msg).toString(enc.Utf8)
}

export { useAESEncrypt, useAESDecrypt, useBase64Encrypt, useBase64Decrypt }
```
> ps: 注意 crypto-js 4.1.1+





### 本地缓存封装
```ts
// `/utils/storage.ts`
/** CacheLocal 本地缓存 */
class CacheLocal {
  static set(key: string, value: any) {
    if (!key || !value || JSON.stringify(value) === '{}') {
      return
    }

    let valueStr = value
    if (typeof value === 'object') {
      valueStr = JSON.stringify(value)
    }

    localStorage.setItem(key, valueStr)
  }

  static get(key: string) {
    if (!key) return

    let result = window.localStorage.getItem(key) || ''
    try {
      return JSON.parse(result)
    } catch (error) {
      return result
    }
  }

  static remove(key: string) {
    if (!key) return

    window.localStorage.removeItem(key)
  }

  /** 清空所有本地缓存 */
  static clear() {
    window.localStorage.clear()
  }
}

/** CacheSession 临时缓存 */
class CacheSession {
  static set(key: string, value: any) {
    if (!key || !value || JSON.stringify(value) === '{}') {
      return
    }

    let valueStr = value
    if (typeof value === 'object') {
      valueStr = JSON.stringify(value)
    }
    window.sessionStorage.setItem(key, valueStr)
  }

  static get(key: string) {
    if (!key) return

    const value = window.sessionStorage.getItem(key) || ''
    try {
      return JSON.parse(value)
    } catch (error) {
      return value
    }
  }

  static remove(key: string) {
    if (!key) return

    window.sessionStorage.removeItem(key)
  }

  /** 清空所有session临时缓存 */
  static clear() {
    window.sessionStorage.clear()
  }
}

export { CacheLocal, CacheSession }

````





### `vuex4-ts`使用规范，有必要可以用`pinia`
- 使用 vue.InjectionKey 保存 所有module-state的类型声明键
```ts
// `/store/index.ts`
import { createStore, Store, useStore as baseUseStore } from 'vuex'
import { InjectionKey } from 'vue'
import { RootStateTypes } from './interface/index'
import userModule from './modules/user'

export const key: InjectionKey<Store<RootStateTypes>> = Symbol('xxx')

export const store = createStore({
  modules: {
    userModule
  }
})

export function useStore() {
  return baseUseStore(key)
}


// `/store/interface/index.ts` 管理所有moduel的state类型声明
/** 顶级类型声明 */
export interface RootStateTypes {
  userState: UserStateTypes
  // ...
}
/** xxxx信息数据类型 */

/** 用户信息数据类型 */
export interface UserStateTypes {
  token: string
  isLogin: boolean
}


// 子模块userModule: `/store/modules/user/index.ts`
import { Module } from 'vuex'
import { UserStateTypes, RootStateTypes } from '../interface/index'
import { userLogin } from '@/api/user'
import { UserLoginRequest } from '@/utils/interfaces/user'
import { useAESEncrypt, useBase64Encrypt } from '@/utils/crypto'

const userModule: Module<UserStateTypes, RootStateTypes> = {
  namespaced: true,
  state: {
    token: '',
    isLogin: false
  },
  mutations: {},
  actions: {
    async loginHandle(context, userInfo: UserLoginRequest) {
      const { username, password } = userInfo
      // 账号: aes加密， 密码: aes+base64加密
      const usernamed = useAESEncrypt(username)
      const passworded = useAESEncrypt(useBase64Encrypt(password))
      return userLogin({ username: usernamed, password: passworded })
    }
  }
}

export default userModule


// vuex的注册: `/main.ts`
import { store, key } from './store'

const app = createApp(App)
app.use(store, key).mount('#app')


// vuex的使用: `/views/login/index.vue`
import { useStore } from '@/store/index'
const store = useStore()
// 取state值
const isLogin = computed(() => store.state.userState.isLogin)
// actions方法触发
store.diptach('userModule/loginHandle', { username, password })
````
> 注意: userModule这样的子模块可以被外界调用内部方法,必须设置: `namespaced: true`






### 登录请求封装规范
- 1.根据需求文档约束请求参数类型、响应参数类型
- 2.结合vuex管理user相关操作的模块处理

登录请求动作:`/api/user.ts`
```ts
import { get, post } from '@/utils/request/service'
import { UserLoginRequest, UserLoginResponse } from '@/utils/interfaces/user'

/**
 * 登录接口
 * @param userInfo
 * @returns
 */
export const userLogin = (userInfo: UserLoginRequest) => {
  // console.log(userInfo)
  return post<UserLoginResponse>('/user/login', userInfo)
}
```
